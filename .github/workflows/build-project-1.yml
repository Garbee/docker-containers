name: Build Project 1

on:
  workflow_dispatch:
  schedule:
    # Run at 3:17 AM UTC every Sunday
    - cron: "17 3 * * 0"
  push:
    branches:
      - main
    paths:
      - "project-1/Dockerfile"
      - ".github/workflows/build-project-1.yml"

permissions:
  # Global permissions for the workflow, which can be overridden at the job level
  contents: read

concurrency:
  # This concurrency group ensures that only one job in the group runs at a time.
  # If a new job is triggered, the previous one will be canceled.
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_NAME: project-1

jobs:
  versions:
    name: Get Latest Tool versions
    runs-on: ubuntu-slim
    outputs:
      zizmor: ${{ steps.get-versions.outputs.zizmor }}
      shfmt: ${{ steps.get-versions.outputs.shfmt }}
      yq: ${{ steps.get-versions.outputs.yq }}
      jq: ${{ steps.get-versions.outputs.jq }}
      gradle: ${{ steps.get-versions.outputs.gradle }}
      actionlint: ${{ steps.get-versions.outputs.actionlint }}
      hadolint: ${{ steps.get-versions.outputs.hadolint }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          persist-credentials: false
      - name: Install Skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo
      - name: Get latest versions
        id: get-versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./bin/get-latest-tool-versions.sh
  # The build job builds the Docker image for each platform specified in the matrix.
  build:
    needs:
      - versions

    permissions:
      attestations: write # Required to provide attestations for the built images.
      contents: read # Ability to clone the repository.
      id-token: write # Required to publish to GHCR.
      packages: write # Ability to publish packages to GHCR.

    strategy:
      fail-fast: false
      matrix:
        platform:
          - linux/amd64
          - linux/arm64
        node-version:
          - 20
          - 22
          - 24

    runs-on: ${{ matrix.platform == 'linux/amd64' && 'ubuntu-24.04' || matrix.platform == 'linux/arm64' && 'ubuntu-24.04-arm' }}
    # The job runs on different runners based on the platform.
    # For linux/amd64, it runs on the latest Ubuntu runner.
    # For linux/arm64, it runs on an Ubuntu 24.04 ARM runner.
    # The runner is selected based on the platform specified in the matrix.

    name: Build for ${{ matrix.platform }} (Node ${{ matrix.node-version }})

    outputs:
      GHCR_IMAGE: ${{ steps.prepare.outputs.GHCR_IMAGE }}

    steps:
      - name: Prepare environment for current platform
        # This step sets up the environment for the current platform being built.
        # It replaces the '/' character in the platform name with '-' and sets it as an environment variable.
        # This is useful for naming artifacts and other resources that cannot contain '/'.
        # The environment variable PLATFORMS_PAIR will be used later in the workflow.
        id: prepare
        env:
          PLATFORM: ${{ matrix.platform }}
          OWNER: ${{ github.repository_owner }}
          NODE_VERSION: ${{ matrix.node-version }}
        run: |
          echo "PLATFORM_PAIR=${PLATFORM//\//-}" >> "$GITHUB_OUTPUT"
          LOWER_OWNER=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          echo "GHCR_IMAGE=ghcr.io/$LOWER_OWNER/${IMAGE_NAME}" >> "$GITHUB_OUTPUT"
          # Set node version suffix for artifact naming
          echo "NODE_SUFFIX=-node${NODE_VERSION}" >> "$GITHUB_OUTPUT"
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          persist-credentials: false
        # This step checks out the code from the repository.
        # It uses the actions/checkout action to clone the repository into the runner's workspace.

      - name: Docker meta default
        # This step generates metadata for the Docker image.
        # It uses the docker/metadata-action to create metadata based on the repository information.
        # The metadata includes information such as the image name, tags, and labels.
        # The metadata will be used later in the workflow to build and push the Docker image.
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ steps.prepare.outputs.GHCR_IMAGE }}

      - name: Set up Docker Context for Buildx
        # This step sets up a Docker context for Buildx.
        # It creates a new context named "builders" that will be used for building the Docker image.
        # The context allows Buildx to use the Docker daemon for building images.
        id: buildx-context
        run: |
          docker context create builders

      - name: Set up Docker Buildx
        # This step sets up Docker Buildx, which is a Docker CLI plugin for extended build capabilities with BuildKit.
        # It uses the docker/setup-buildx-action to configure Buildx with the specified context and platforms.
        # The platforms are specified in the matrix and will be used for building the Docker image.
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
        with:
          endpoint: builders
          platforms: ${{ matrix.platform }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        # This step builds and pushes the Docker image using Buildx.
        # It uses the docker/build-push-action to build the image with the specified context and platforms.
        # The image is built with the labels and annotations generated in the previous steps.
        # The outputs are configured to push the image by digest, which allows for better caching and versioning.
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        env:
          DOCKER_BUILDKIT: 1
        with:
          context: ./project-1
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          build-args: |
            NODE_VERSION=${{ matrix.node-version }}
            SHFMT_VERSION=${{ needs.versions.outputs.shfmt }}
            YQ_VERSION=${{ needs.versions.outputs.yq }}
            ZIZMOR_VERSION=${{ needs.versions.outputs.zizmor }}
            JQ_VERSION=${{ needs.versions.outputs.jq }}
            GRADLE_VERSION=${{ needs.versions.outputs.gradle }}
            ACTIONLINT_VERSION=${{ needs.versions.outputs.actionlint }}
            HADOLINT_VERSION=${{ needs.versions.outputs.hadolint }}
          outputs: type=image,name=${{ steps.prepare.outputs.GHCR_IMAGE }},push-by-digest=true,name-canonical=true,push=true,oci-mediatypes=true

      - name: Export digest
        env:
          DIGEST: ${{ steps.build.outputs.digest }}
        # This step exports the digest of the built image to a file.
        # It creates a directory in /tmp/digests and saves the digest of the image to a file.
        # The digest is obtained from the output of the build step.
        # The digest is used to uniquely identify the built image and can be used for further processing or verification.
        run: |
          mkdir -p /tmp/digests
          touch "/tmp/digests/${DIGEST#sha256:}"

      - name: Upload digest
        # This step uploads the digest file to the GitHub Actions artifact storage.
        # It uses the actions/upload-artifact action to upload the file created in the previous step.
        # The artifact is retained for 1 day, and if no files are found, it will throw an error.
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: digests-${{ steps.prepare.outputs.PLATFORM_PAIR }}${{ steps.prepare.outputs.NODE_SUFFIX }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    # This job merges the Docker manifests for the different platforms built in the previous job.
    name: Merge Docker manifests (Node ${{ matrix.node-version }})
    runs-on: ubuntu-latest

    permissions:
      attestations: write # Required to provide attestations for the built images.
      contents: read # Ability to clone the repository.
      id-token: write # Required to publish to GHCR.
      packages: write # Ability to publish packages to GHCR.

    strategy:
      fail-fast: false
      matrix:
        node-version:
          - 20
          - 22
          - 24

    needs:
      - build

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          persist-credentials: false

      - name: Prepare node version suffix
        id: node-prepare
        env:
          NODE_VERSION: ${{ matrix.node-version }}
        run: |
          # Set node version suffix for artifact pattern and tags
          echo "NODE_SUFFIX=-node${NODE_VERSION}" >> "$GITHUB_OUTPUT"
          echo "NODE_TAG_SUFFIX=-node${NODE_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Download digests
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          path: /tmp/digests
          pattern: digests-*${{ steps.node-prepare.outputs.NODE_SUFFIX }}
          merge-multiple: true

      - name: Generate Docker tag
        id: tag_info
        env:
          EVENT_NAME: ${{ github.event_name }}
          SHA: ${{ github.sha }}
          RUN_NUMBER: ${{ github.run_number }}
          RUN_ATTEMPT: ${{ github.run_attempt }}
          NODE_SUFFIX: ${{ steps.node-prepare.outputs.NODE_TAG_SUFFIX }}
        run: |
          YEAR_WEEK=$(date -u +"%Y-W%V")

          case "$EVENT_NAME" in
            schedule)
              RUN_TYPE="scheduled"
              UNIQUE="${RUN_NUMBER}-${RUN_ATTEMPT}"
              ;;
            push)
              RUN_TYPE="push"
              UNIQUE="${SHA:0:7}"
              ;;
            workflow_dispatch)
              RUN_TYPE="manual"
              UNIQUE="${RUN_NUMBER}-${RUN_ATTEMPT}-$(date -u +"%H%M%S")"
              ;;
            *)
              RUN_TYPE="$EVENT_NAME"
              UNIQUE="${RUN_NUMBER}-${RUN_ATTEMPT}"
              ;;
          esac

          TAG="${YEAR_WEEK}-${RUN_TYPE}-${UNIQUE}${NODE_SUFFIX}"

          echo "Docker Tag: $TAG"
          echo "TAG=$TAG" >> "$GITHUB_OUTPUT"

      - name: Docker meta
        # This step generates metadata for the Docker image.
        # It uses the docker/metadata-action to create metadata based on the repository information.
        # The metadata includes information such as the image name, tags, and labels.
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ needs.build.outputs.GHCR_IMAGE }}
          annotations: |
            type=org.opencontainers.image.description,value=Development container with Node.js, Java, Gradle, Python, and browser testing tools
            type=org.opencontainers.licenses,value=CC-PDM-1.0
            type=org.opencontainers.image.url,value=https://github.com/garbee/docker-containers
          tags: |
            type=raw,value=main${{ steps.node-prepare.outputs.NODE_TAG_SUFFIX }},enable=${{ github.ref_name == 'main' }}
            type=raw,value=latest,enable=${{ github.ref_name == 'main' && matrix.node-version == '22' }}
            type=raw,value=${{ steps.tag_info.outputs.TAG }}
            type=raw,value=on:manual${{ steps.node-prepare.outputs.NODE_TAG_SUFFIX }},enable=${{ github.event_name == 'workflow_dispatch' }}
            type=raw,value=on:scheduled${{ steps.node-prepare.outputs.NODE_TAG_SUFFIX }},enable=${{ github.event_name == 'schedule' }}
            type=raw,value=on:push${{ steps.node-prepare.outputs.NODE_TAG_SUFFIX }},enable=${{ github.event_name == 'push' }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
        with:
          driver-opts: |
            network=host

      - name: Login to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        # This step logs in to the GitHub Container Registry (GHCR) using the docker/login-action.
        # It uses the GitHub actor's username and the GITHUB_TOKEN secret for authentication.
        # The login is necessary to push the merged manifest list to GHCR.
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and pushes
        # This step creates a manifest list for the Docker images built for different platforms.
        # It uses the docker buildx imagetools create command to create the manifest list.
        # The manifest list is annotated with metadata such as description, creation timestamp, and source URL.
        # The annotations are obtained from the metadata generated in the previous steps.
        # The manifest list is pushed to the GitHub Container Registry (GHCR) with the specified tags.
        id: manifest-annotate
        continue-on-error: false
        env:
          NEEDS_BUILD_OUTPUTS_GHCR_IMAGE: ${{ needs.build.outputs.GHCR_IMAGE }}
          NODE_VERSION: ${{ matrix.node-version }}
          DIGEST_PATH: /tmp/digests
        run: ./bin/create-manifests-and-push.sh

      # This step inspects the created manifest list to verify its contents.
      # It uses the docker buildx imagetools inspect command to display information about the manifest list.
      # The inspection output will show the platforms and tags associated with the manifest list.
      - name: Inspect image
        id: inspect
        env:
          IMAGE: "${{ needs.build.outputs.GHCR_IMAGE }}:${{ steps.meta.outputs.version }}"
        run: docker buildx imagetools inspect "$IMAGE"

      - name: Delete Artifacts
        uses: geekyeggo/delete-artifact@f275313e70c08f6120db482d7a6b98377786765b # v5.1.0
        with:
          name: |
            digests-*${{ steps.node-prepare.outputs.NODE_SUFFIX }}
